{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Mathematical models for economic applications"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Owner**: Thomas De Massari    \n",
    "**e-mail**: thomas.demassari@gmail.com     \n",
    "**Linkedin**: https://www.linkedin.com/in/thomasdemassari/  \n",
    "**GitHub**: https://github.com/thomasdemassari/\n",
    "\n",
    "During the last semester of my BSc (February-May 2024), I attended the Mathematical Models for Economic Applications course, held by Professor Silvia Bortot and Professor Ricardo Alberto Marques Pereira. In this file, you will find functions that I created to solve exercises related to the topics covered in class. The primary goal of these functions is to improve my Python programming skills while studying for the final exam. Furthermore, I am fully aware that there might be more efficient ways to implement some of the algorithms and more efficient Python functions, but the purpose of these scripts is to solve the course exercises in Python. For any questions or requests for information, please contact me at thomas.demassari@gmail.com   \n",
    "\n",
    "Main topics of the course:      \n",
    "- Introductory Linear Algebra           \n",
    "- Linear Programming (Simplex Algorithm and Knapsack Problem)       \n",
    "- Dynamic Models (Consensus Dynamics and Linear Dynamic Population Redistribution)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Libraries"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Last update: 2024-07-16 07:47:00\n"
     ]
    }
   ],
   "source": [
    "import numpy as np \n",
    "import math \n",
    "import pandas as pd\n",
    "import scipy\n",
    "\n",
    "from itertools import combinations\n",
    "\n",
    "import warnings\n",
    "warnings.simplefilter(action = \"ignore\", category = FutureWarning)\n",
    "\n",
    "from datetime import datetime\n",
    "print(f\"Last update: {datetime.now().replace(second = 0, microsecond = 0)}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Introductory matrix algebra\n",
    "- Matrix addition           \n",
    "- Matrix multiplication             \n",
    "- Determinant of a matrix           \n",
    "- Inverse matrix            \n",
    "- Minor of a matrix             \n",
    "- Rank of a matrix              \n",
    "- Gaussian elimination method for solving a linear system               \n",
    "- Right and left eigenvectors"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Matrix addition"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "def matrixplusmatrix(matrix1, matrix2):\n",
    "    try:\n",
    "        row1 = matrix1.shape[0]                                 # Number of rows of the first matrix\n",
    "        col1 = matrix1.shape[1]                                 # Number of columns of the first matrix\n",
    "        row2 = matrix2.shape[0]                                 # Number of rows of the second matrix\n",
    "        col2 = matrix2.shape[1]                                 # Number of columns of the second matrix\n",
    "        if (row1 == row2) and (col1 == col2):                   # The two matrixs must have the same dimensions\n",
    "            result = np.zeros((row1, col1))\n",
    "            for i in range(row1):\n",
    "                for j in range(col1):\n",
    "                    result[i][j] = matrix1[i][j] + matrix2[i][j]\n",
    "            return result\n",
    "        else:\n",
    "            raise Exception(\"The two matrixs have different dimensions.\") \n",
    "    except:\n",
    "        raise Exception(\"ERROR: Something went wrong. Please pass valid values for the parameters\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Matrix multiplication"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "def matrixtimesmatrix(matrix1,matrix2):\n",
    "    try:\n",
    "        row1 = matrix1.shape[0]                         # Number of rows of the first matrix\n",
    "        col1 = matrix1.shape[1]                         # Number of columns of the first matrix\n",
    "        row2 = matrix2.shape[0]                         # Number of rows of the second matrix\n",
    "        col2 = matrix2.shape[1]                         # Number of columns of the second matrix\n",
    "\n",
    "        if (col1 == row2):                              # The two matrices must be conformable\n",
    "            result = np.zeros((row1, col2))\n",
    "            for i in range(row1):\n",
    "                for j in range(col2):\n",
    "                    for k in range(col1):\n",
    "                        tmp = matrix1[i][k]*matrix2[k][j]\n",
    "                        result[i][j] = result[i][j] + tmp\n",
    "            return result        \n",
    "    except:\n",
    "        raise Exception(\"ERROR: Something went wrong. Please pass valid values for the parameters\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Determinant of a matrix"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "def determinant(matrix):\n",
    "    try:\n",
    "        row = matrix.shape[0]                                                               # Number of rows of the first matrix\n",
    "        col = matrix.shape[1]                                                               # Number of columns of the first matrix\n",
    "\n",
    "        result = 0\n",
    "        if (row == col):\n",
    "            if row == 1:\n",
    "                result = matrix[0][0]\n",
    "                result = round(result, 2)\n",
    "                return result\n",
    "            else:\n",
    "                if row == 2:\n",
    "                    result = ((matrix[0][0]*matrix[1][1]) - (matrix[0][1]*matrix[1][0]))\n",
    "                    result = round(result, 2)\n",
    "                    return result\n",
    "                else:\n",
    "                    if row == 3:                                                             # Rule of Sarrus\n",
    "                        col0 = matrix[:,0]\n",
    "                        col1 = matrix[:,1]\n",
    "                        sarrus_matrix = np.concatenate((matrix, col0[:, np.newaxis], col1[:, np.newaxis]), axis=1)\n",
    "                        i = 0\n",
    "                        j = 0\n",
    "                        for i in range(3):\n",
    "                            tmp1 = sarrus_matrix[0][i]*sarrus_matrix[1][i+1]*sarrus_matrix[2][i+2]\n",
    "                            result = result + tmp1\n",
    "                        for j in range(3):\n",
    "                            tmp2 = (sarrus_matrix[2][j]*sarrus_matrix[1][j+1]*sarrus_matrix[0][j+2])\n",
    "                            result = result - tmp2\n",
    "                        result = round(result, 2)\n",
    "                        return result\n",
    "                    else:                                                                    # Laplace expansion (row = 0)\n",
    "                        j = 0\n",
    "                        for j in range(col):\n",
    "                            minor = np.delete(np.delete(matrix, 0, axis=0), j, axis=1)\n",
    "                            complementary_minor =  np.linalg.det(minor) \n",
    "                            tmp = matrix[0][j]*((-1)**j)*complementary_minor\n",
    "                            result = result + tmp\n",
    "                        result = round(result, 2)\n",
    "                        return result                   \n",
    "        else:\n",
    "            print(\"The provided input is not a square matrix.\") \n",
    "    except:\n",
    "        raise Exception(\"ERROR: Something went wrong. Please pass valid values for the parameters\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Inverse matrix"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "def inversematrix(matrix):\n",
    "    try:\n",
    "        row = matrix.shape[0]                                                       # Number of rows of the first matrix\n",
    "        col = matrix.shape[1]                                                       # Number of columns of the first matrix\n",
    "\n",
    "        if (row == col):\n",
    "            det = determinant(matrix)\n",
    "            inverse_matrix = np.zeros((row, col))\n",
    "            if det != 0:\n",
    "                for i in range(row):\n",
    "                    for j in range(col):\n",
    "                        complementary_minor = np.linalg.det(np.delete(np.delete(matrix, j, axis=0), i, axis=1))\n",
    "                        complementary_algebraic = ((-1)**(j+i))*complementary_minor\n",
    "                        tmp = complementary_algebraic/det\n",
    "                        inverse_matrix[i][j] = tmp\n",
    "                return inverse_matrix        \n",
    "            else:\n",
    "                print(\"The determinant of the matrix is zero. The inverse matrix does not exist.\")\n",
    "\n",
    "        else:\n",
    "            print(\"The provided input is not a square matrix.\") \n",
    "\n",
    "    except:\n",
    "        raise Exception(\"ERROR: Something went wrong. Please pass valid values for the parameters\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Minor of a matrix"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "def minor(matrix, show = False, order = \"all\"):\n",
    "    try:\n",
    "        row = matrix.shape[0]\n",
    "        col = matrix.shape[1]\n",
    "        nminors_max = min(row, col)\n",
    "        rows = list(range(row))\n",
    "        cols = list(range(col))\n",
    "\n",
    "        n_minors = 0 \n",
    "        k = 1\n",
    "        for k in range(1, nminors_max+1):\n",
    "            n_minors = math.comb(row, k)*math.comb(col, k) + n_minors\n",
    "\n",
    "        # All possible combinations between rows and columns\n",
    "        all_combinations = list()\n",
    "        # Add all possible combinations between vector1 and vector2\n",
    "        for length in range(1, min(len(rows), len(cols)) + 1):\n",
    "            for combination1 in combinations(rows, length):\n",
    "                for combination2 in combinations(cols, length):\n",
    "                    combination1 = list(combination1)\n",
    "                    combination2 = list(combination2)\n",
    "                    all_combinations.append((combination1, combination2))\n",
    "        # Add combinations with different lengths between vector1 and vector2\n",
    "        for combination1 in combinations(rows, len(rows)):\n",
    "            for combination2 in combinations(cols, len(cols)):\n",
    "                combination1 = list(combination1)\n",
    "                combination2 = list(combination2)\n",
    "                all_combinations.append((combination1, combination2))\n",
    "\n",
    "        # Consider only the combinations with the same length (squared matrixs)\n",
    "        vector_of_combinations = list()\n",
    "        for i in range(len(all_combinations)):\n",
    "            if len(all_combinations[i][0]) == len(all_combinations[i][1]):\n",
    "                vector_of_combinations.append(all_combinations[i])\n",
    "\n",
    "        # Rows and cols of the minors \n",
    "        m = [vector_of_combinations[i][0] for i in range(len(vector_of_combinations))]\n",
    "        n = [vector_of_combinations[j][1] for j in range(len(vector_of_combinations))]\n",
    "\n",
    "        counter = 0\n",
    "        list_of_minors = list()\n",
    "\n",
    "        for i in range(len(m)):\n",
    "                output = (matrix[m[i]][:, n[i]])\n",
    "                list_of_minors.append(output)\n",
    "                counter = counter + 1\n",
    "\n",
    "        if (order == \"all\"):\n",
    "            if show == True:\n",
    "                print(f\"Minor of order: {len(m[i])}:\\n{output}\")\n",
    "                if counter == n_minors:\n",
    "                    print(f\"All minors ({counter}) have been calculated.\")\n",
    "                else:\n",
    "                    print(f\"Not all minors have been calculated. Only {counter} of {n_minors} have been calculated.\")\n",
    "            # list_of_minors = np.array(list_of_minors)\n",
    "            return list_of_minors\n",
    "        else:\n",
    "            list_of_k_order_minors = list()\n",
    "            for z in range(len(list_of_minors)):\n",
    "                if len(list_of_minors[z]) == order:\n",
    "                    list_of_k_order_minors.append((list_of_minors[z]))\n",
    "            # list_of_k_order_minors = np.array(list_of_k_order_minors)\n",
    "            return list_of_k_order_minors\n",
    "                    \n",
    "    except:\n",
    "        raise Exception(\"ERROR: Something went wrong. Please pass valid values for the parameters\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Rank of a matrix"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "def rank(matrix):\n",
    "    try:\n",
    "        row = matrix.shape[0]\n",
    "        col = matrix.shape[1]\n",
    "\n",
    "        max_order = min(row, col)\n",
    "\n",
    "        index = list(range(1, max_order+1))\n",
    "        index.reverse()\n",
    "\n",
    "        rank_of_the_matrix = 0\n",
    "        k = 1\n",
    "        for k in index:\n",
    "            minors = minor(matrix, order = k)\n",
    "            minors = np.array(minors)\n",
    "            list_tmp = list()\n",
    "            for i in range(minors.shape[0]):\n",
    "                tmp = determinant(minors[i])\n",
    "                list_tmp.append(tmp)\n",
    "                if all(element == 0 for element in list_tmp):\n",
    "                    rank_of_the_matrix = k - 1\n",
    "        return rank_of_the_matrix\n",
    "\n",
    "    except:\n",
    "        raise Exception(\"ERROR: Something went wrong. Please pass valid values for the parameters\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Gaussian elimination method for solving a linear system"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def check_diagonal(matrix):\n",
    "    try:\n",
    "        for i in range(len(matrix)):\n",
    "            for j in range(len(matrix[0])):\n",
    "                if i > j and matrix[i][j] != 0:\n",
    "                    return False\n",
    "        return True\n",
    "    except:\n",
    "        raise Exception(\"ERROR: Something went wrong. Please pass valid values for the parameters\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "def guassian_elimination(matrixA, matrixB):\n",
    "    try:\n",
    "        np.seterr(divide='ignore', invalid='ignore')                                                    #ignore the warning of division by zero\n",
    "\n",
    "        matrixAB = np.concatenate((matrixA, matrixB), axis=1)\n",
    "\n",
    "        rowA = int(matrixA.shape[0])\n",
    "        colA = int(matrixA.shape[1])\n",
    "\n",
    "        target = np.zeros((rowA, colA+1))\n",
    "        final_target = np.zeros((rowA, colA+1))\n",
    "\n",
    "        if rank(matrixA) == rank(matrixAB):\n",
    "            #Gaussian elimination        \n",
    "            index1 = list(range(rowA))\n",
    "            index2 = list(range(colA))\n",
    "\n",
    "            for j in range(colA):\n",
    "                if matrixAB[0][0] != 1 or matrixAB[0][0] != 0:\n",
    "                    target[0][j] = matrixAB[0][j]/matrixAB[0][0]\n",
    "                else:\n",
    "                    target[0][j] = matrixAB[0][j]\n",
    "\n",
    "            \n",
    "            # Find the indices of the first non-zero element in each row\n",
    "            row_indices, col_indices = np.nonzero(matrixA)\n",
    "            # Filter only the indices of the first occurrence of each row\n",
    "            unique_row_indices, first_col_indices = np.unique(row_indices, return_index=True)\n",
    "            # Get the indices of the first non-zero element in each row\n",
    "            first_nonzero_indices = (unique_row_indices, col_indices[first_col_indices])                #rows in the first element, cols in the second element\n",
    "\n",
    "            i = 1\n",
    "            j = 0\n",
    "            for i in range(1, rowA):\n",
    "                index_col = first_nonzero_indices[1][i]\n",
    "                coeff = (matrixAB[i][index_col]/matrixAB[i-1][index_col])\n",
    "                \n",
    "                for j in range(colA + 1):\n",
    "                        if matrixAB[i][j] != 0:\n",
    "                            target[i][j] = matrixAB[i][j] - (matrixAB[i-1][j]*coeff)\n",
    "                            tmp = False\n",
    "                        else:\n",
    "                            target[i][j] = matrixAB[i][j]\n",
    "                            tmp = False\n",
    "\n",
    "                correctness = check_diagonal(target)\n",
    "                if correctness == True:\n",
    "                    break\n",
    "                else:\n",
    "                    continue\n",
    "\n",
    "            i = 1\n",
    "            j = 0\n",
    "\n",
    "            for j in range(colA +1):\n",
    "                final_target[0][j] = target[0][j]\n",
    "\n",
    "            for i in range(1, rowA):\n",
    "                for j in range(colA + 1):\n",
    "                    if target[i][i] != 1 or target[i][i] != 1:\n",
    "                        final_target[i][j] = target[i][j]/target[i][i]\n",
    "                    else:\n",
    "                        final_target[i][j] = target[i][j]\n",
    "            \n",
    "            final_target[np.isnan(final_target)] = 0\n",
    "            return final_target\n",
    "                        \n",
    "        else:\n",
    "            print(\"The system has no solution.\")   \n",
    "    except:\n",
    "        raise Exception(\"ERROR: Something went wrong. Please pass valid values for the parameters\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Right and left eigenvectors"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 106,
   "metadata": {},
   "outputs": [],
   "source": [
    "def eigeinvectors_calculator(matrix, side = \"right\"):\n",
    "    try:\n",
    "        eingenvalues = np.linalg.eigvals(matrix)\n",
    "        I_matrix = np.eye(len(matrix[0]), len(matrix[:, 0]))                                                    # Identity matrix\n",
    "\n",
    "        result = pd.DataFrame(columns = [\"Eigenvalue\", \"Eigenvector\"])\n",
    "\n",
    "        for i in range(len(eingenvalues)):\n",
    "            eingenvalue = round(eingenvalues[i], 5)\n",
    "            a = matrix - (eingenvalue * I_matrix)                                                               # (A - lamba*I)\n",
    "            b = np.zeros((len(matrix[:, 0]), 1))                                                                # 0, 0, ..., 0\n",
    "\n",
    "            # Right eigenvector\n",
    "            if side == \"right\":\n",
    "                # Solve the linear system x*(A-lambda*I) = 0\n",
    "                x = scipy.linalg.null_space(a)                                                                  # x1, x2, ..., x_n, i.e the eigenvector \n",
    "\n",
    "                # Check the solution of the linear system\n",
    "                if np.allclose(np.dot(a, x), b) == False:\n",
    "                    raise Exception(\"ERROR: The function get wrong\")\n",
    "                \n",
    "            else:\n",
    "                # Left eigenvector\n",
    "                if side == \"left\":\n",
    "                    # Solve the linear system (A-lambda*I)T * x = 0 (which is equivalent to solving xT * (A-lambda*I) = 0)\n",
    "                    x = scipy.linalg.null_space(a.T)\n",
    "\n",
    "                    # Check the solution of the linear system\n",
    "                    if np.allclose(np.dot(a.T, x), b) == False:\n",
    "                        raise Exception(\"ERROR: The function get wrong\")\n",
    "                    \n",
    "                else:\n",
    "                    raise Exception(\"ERROR: Please pass a valid value for the parameter 'side' (either 'left' or 'right').\")\n",
    "            \n",
    "            # Save the result\n",
    "            x = np.round(x, 5)\n",
    "            newrow = {\"Eigenvalue\": [eingenvalue], \"Eigenvector\": [x]}\n",
    "            result.loc[len(result)] = newrow\n",
    "\n",
    "        return result\n",
    "    except:\n",
    "        raise Exception(\"ERROR: Something went wrong. Please pass valid values for the parameters\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def solve_linearsystem(matrixA, matrixB, n_unknowns = 0, show_number_and_type_of_solutions = False):\n",
    "#NB this function doesn't provide the numerical solution of the linear system, but provides only the linear equations to solve the system. \n",
    "    try:\n",
    "        reduced_form_matrix = guassian_elimination(matrixA, matrixB)\n",
    "\n",
    "         #Matrix with only the basics varaibles\n",
    "        non_zero_mask = ~np.all(reduced_form_matrix == 0, axis=1)\n",
    "        matrix_no0 = reduced_form_matrix[non_zero_mask]\n",
    "\n",
    "        row = reduced_form_matrix.shape[0]\n",
    "        col = reduced_form_matrix.shape[1]\n",
    "\n",
    "        row_no0 = matrix_no0.shape[0]\n",
    "        col_no0 = matrix_no0.shape[1]\n",
    "\n",
    "        #number of solutions and type of variables\n",
    "        if show_number_and_type_of_solutions == True:\n",
    "            basicsvar = list()\n",
    "            freevar = list()\n",
    "            if n_unknowns == 0:\n",
    "                print(\"Please provide the number of unknowns.\")\n",
    "            else:\n",
    "                if (n_unknowns - rank(matrixA) == 0):\n",
    "                    print(\"The system has a unique solution:\\n\")\n",
    "                else:\n",
    "                    print(f\"The system has ∞^{n_unknowns - rank(matrixA)} solutions:\\n\")\n",
    "            #Basics and free variables\n",
    "            for i in range(row):\n",
    "                tmp = f\"x{i+1}\"\n",
    "                if reduced_form_matrix[i][i] == 1 or reduced_form_matrix[i][i] == -1:\n",
    "                    basicsvar.append(tmp)\n",
    "                else:\n",
    "                    freevar.append(tmp)\n",
    "            print(f\"Basics variables: {basicsvar}\\nFree variables: {freevar}\\n\")\n",
    "       \n",
    "        #Modify the matrix with the names of the variables\n",
    "        matrix_with_varnames = np.empty((row, col), dtype=object)\n",
    "        for i in range(row_no0):\n",
    "            for j in range(col_no0-1):\n",
    "                matrix_with_varnames[i][j] = f\"{reduced_form_matrix[i][j]}x{j+1}\"\n",
    "        for i in range(row):\n",
    "            matrix_with_varnames[i][-1] = reduced_form_matrix[i][-1]\n",
    "\n",
    "        # print(\"Final result:\")\n",
    "        final_result = list()\n",
    "        for i in range(row_no0):\n",
    "            tmp = f\"x{i+1} = {matrix_with_varnames[i][i+1:]}\"\n",
    "            final_result.append(tmp)\n",
    "            # print(tmp)\n",
    "        return final_result\n",
    "\n",
    "    except:\n",
    "        raise Exception(\"ERROR: Something went wrong. Please pass valid values for the parameters\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Linear programming\n",
    "- Simplex Algotithm       \n",
    "- I/O Knapsack Problem using Branch and Bound Algotithm"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Simplex Algorithm\n",
    "The following function solves problems of minimum and maximum using the Simplex Algorithm. It takes the following inputs:                \n",
    "- *function_to_minimax* (as a np.array), containing the function to maximize (minimize);            \n",
    "- *constraints* (as a np.array), containing the constraints of the problem;            \n",
    "- *goal* (as a string). If it is a maximum problem, goal is set to \"max\"; if it is a minimum problem, goal is set to \"min\".                 \n",
    "\n",
    "The *SimplexAlgorithm* function calls four other functions:         \n",
    "- *entryANDexit_criteria*, to find a new base, according to Simplex Algorithm. It returns two lists, one with indices and one with names of base variables;     \n",
    "- *MoveToAnotherVertex*, to compute the right matrix according to the new base variables, calculated with this function;        \n",
    "- *Matrix_Primal2DualProbelm*, to calculate the matrix of the dual problem;     \n",
    "- *Solution_Dual2PrimalProblem*, to find the solution of the primal problem, given the solution of the dual one.        \n",
    "\n",
    "**Example**         \n",
    "Given the problem:\n",
    "$$\n",
    "max\\,\\,\\,6x_1 + 2x_2 + 4x_3 = 0                       \n",
    "$$ \n",
    "$$           \n",
    "s.t.\n",
    "\\begin{cases}\n",
    "x_1 + 2x_2 + 3x_3 \\leq 60\\\\\n",
    "2x_1 + x_2 + x_3 \\leq 30\n",
    "\\end{cases}\n",
    "$$\n",
    "\n",
    "The *SimplexAlgorithm* function takes as inputs:            \n",
    "```python\n",
    "function_to_minimax = np.array([[6, 2, 4, 0]])\n",
    "constraints = np.array([[1, 2, 3, 60],\n",
    "                        [2, 1, 1, 30]])\n",
    "```\n",
    "And the output will be:             \n",
    "```python\n",
    "                                     0\n",
    "max value of the function        108.0\n",
    "Names of base variables       [x1, x3]\n",
    "Values of base variables   [6.0, 18.0]\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "def entryANDexit_criteria(complete_matrix, constraints_index, names_of_variables, names_of_constraints, goal = \"max\"):\n",
    "    \"\"\"\n",
    "    This function takes the complete_matrix, constraints_index, names_of_variables, names_of_constraints and goal (all computed by the SimplexAlgorithm function) as parameters and returns a new set of base variables (and relative names) according to Simplex Algorithm.\n",
    "    NB: I am fully aware know that the nomenclature \"constraints_index\" to indicate the indices of base variables could be tricky, but it was useful to me when I wrote the first version of this code.\n",
    "    \"\"\"\n",
    "\n",
    "    try:\n",
    "        # Working matrix to pd.Dataframe\n",
    "        # Names of rows and cols\n",
    "        rows = names_of_constraints + [\"z\"]\n",
    "        cols = names_of_variables + [\"value\"] \n",
    "        df_working_matrix = pd.DataFrame(complete_matrix, index = rows, columns = cols)\n",
    "\n",
    "        z_lines_complete_matrix = list(complete_matrix[-1, :][:-1])                                       # Line of function to minimax\n",
    "\n",
    "\n",
    "        # ENTRY CRITERIA\n",
    "        entry_criteria_index_list = list()                                                                # Where I will save the index of possible values of the entry criteria\n",
    "        entry_criteria_values_list = list()                                                               # Where I will save the possible values of entry criteria \n",
    "        entry_criteria_names_list = list()                                                                # Where I will save the possible names of variables of entry criteria\n",
    "\n",
    "        for i in range(len(z_lines_complete_matrix)):\n",
    "            if i in constraints_index:                                                                    # constraints_index contains the indices of the positions of the base variables\n",
    "                continue\n",
    "            else:\n",
    "                if goal == \"max\":\n",
    "                    if z_lines_complete_matrix[i] < 0:\n",
    "                        entry_criteria_index_list.append(i)                                               # Save the index\n",
    "                        entry_criteria_values_list.append(abs(z_lines_complete_matrix[i]))                # Save the abs of the value\n",
    "                        entry_criteria_names_list.append(names_of_variables[i])                           # Save the name of the variable\n",
    "                if goal == \"min\":\n",
    "                    raise Exception(\"Something went wrong. This function solves minimization problems using the Duality Theorem.\")\n",
    "\n",
    "        entry_criteria_selection_value = max(entry_criteria_values_list)                                                   # Value of the variable that will entry \n",
    "        entry_criteria_index = entry_criteria_index_list[entry_criteria_values_list.index(entry_criteria_selection_value)] # Index of the variable that will entry\n",
    "        entry_criteria_name = entry_criteria_names_list[entry_criteria_values_list.index(entry_criteria_selection_value)]  # Name of the variable that will entry\n",
    "\n",
    "\n",
    "        # EXIT CRITERIA\n",
    "        col_of_entry_criteria = complete_matrix[:, entry_criteria_index][:-1]                              # Column where select the exit value\n",
    "        col_of_constraints_bound = complete_matrix[:, -1][:-1]                                             # Column of values of constraints (i.e. col where there are 60 in constraint x1 - x2 < 60)\n",
    "\n",
    "        exit_criteria_values_list = list()                                                                 # Where I will save values of possibile of exit value\n",
    "        exit_criteria_indexs_list = list()                                                                 # Where I will save the index of possible values of the entry criteria\n",
    "\n",
    "        for j in range(len(col_of_entry_criteria)):\n",
    "            if col_of_entry_criteria[j] > 0:\n",
    "                exit_ratio_tmp = col_of_constraints_bound[j]/col_of_entry_criteria[j]                      # b_i/a_ij\n",
    "                exit_criteria_values_list.append(exit_ratio_tmp)                                           # Save the value, if non-negative\n",
    "                exit_criteria_indexs_list.append(j)                                                        # Save the respective index\n",
    "\n",
    "        if len(exit_criteria_indexs_list) == 0:\n",
    "            constraints_index = \"Unbounded Optimal Solution\"\n",
    "            names_of_constraints = \"Unbounded Optimal Solution\"\n",
    "            return constraints_index, names_of_constraints\n",
    "\n",
    "        exit_criteria_value = min(exit_criteria_values_list)                                               # Value of the variable that will exit \n",
    "        exit_criteria_name = df_working_matrix.index[exit_criteria_indexs_list[exit_criteria_values_list.index(exit_criteria_value)]] # Name of the variable that will exit\n",
    "\n",
    "        exit_criteria_index = df_working_matrix.columns.get_loc(exit_criteria_name)                        # Index of the variable that will exit\n",
    "\n",
    "        # FIND THE NEW BASE VARIABLES\n",
    "        exit_index_in_constraints_index_list = constraints_index.index(exit_criteria_index)                # Index in constraints_index of the exit variable\n",
    "        constraints_index[exit_index_in_constraints_index_list] = entry_criteria_index     \n",
    "        constraints_index.sort()\n",
    "\n",
    "        names_of_constraints[exit_index_in_constraints_index_list] = entry_criteria_name\n",
    "        names_of_constraints = sorted(names_of_constraints, key=lambda x: names_of_variables.index(x))\n",
    "\n",
    "        return constraints_index, names_of_constraints\n",
    "    except:\n",
    "        raise Exception(\"ERROR: Something went wrong in the entryANDexit_criteria. Please check the passed values.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "def MoveToAnotherVertex(complete_matrix, constraints_index):\n",
    "    \"\"\"\n",
    "    This function takes the complete_matrix and the constraints_index (both computed by the SimplexAlgorithm function) as parameters and returns a new matrix based on the index of base variables (constraints_index) that are passed, according to Simplex Algorithm. \n",
    "    NB: I am fully aware that the nomenclature \"constraints_index\" to indicate the indices of base variables could be tricky, but it was useful to me when I wrote the first version of this code.\n",
    "    \"\"\"\n",
    "    try:\n",
    "        tmp_matrix = np.zeros(np.shape(complete_matrix))                                                # Empty matrix where I will save the new complete_matrix\n",
    "        tmp_constraints_value_for_matrix = np.eye(len(complete_matrix[:,0]), len(constraints_index))    # Diagonal matrix\n",
    "        target_matrix = np.zeros(np.shape(complete_matrix))                                             # Target matrix. If I will do all right, tmp_matrix will equal to target_matrix\n",
    "\n",
    "        for i in range(len(constraints_index)):\n",
    "            den_to_one = complete_matrix[i, constraints_index[i]]                                       # Value to have 1 in position (i, constraints_index[i])\n",
    "            if den_to_one != 0:\n",
    "                for j in range(len(complete_matrix[i,:])):\n",
    "                    tmp_matrix[i, j] = complete_matrix[i, j] / den_to_one\n",
    "            else:\n",
    "                raise Exception(\"Unhandled error.\")                                                     # If the code will go here means that something went wrong in the Simplex Algorithm\n",
    "            \n",
    "            for index_addtozero_rows in range(len(complete_matrix[:, 0])):\n",
    "                if i != index_addtozero_rows:                                                           # If the row i is different than index_addtozero_rows means that we are in a line where we want a 0 under the base variable constraints_index[i]\n",
    "                    add_to_zero = (complete_matrix[index_addtozero_rows, constraints_index[i]]) / (complete_matrix[i, constraints_index[i]]) \n",
    "                    \n",
    "                    for index_addtozero_cols in range(len(complete_matrix[0, :])):\n",
    "                        tmp = (complete_matrix[i, index_addtozero_cols] * (- add_to_zero)) + complete_matrix[index_addtozero_rows, index_addtozero_cols]\n",
    "                        tmp_matrix[index_addtozero_rows, index_addtozero_cols] = tmp\n",
    "                            \n",
    "            complete_matrix = tmp_matrix\n",
    "\n",
    "        # Complete the target matrix and control if tmp_matrix equals to target_matrix\n",
    "        for j in range(len(complete_matrix[0,:])):\n",
    "            if j in constraints_index:\n",
    "                target_matrix[:, j] = tmp_constraints_value_for_matrix[:, constraints_index.index(j)]\n",
    "            else:\n",
    "                target_matrix[:, j] = complete_matrix[:, j]\n",
    "        \n",
    "        control = list()\n",
    "        for j in range(len(complete_matrix[0,:])):\n",
    "            if j in constraints_index:\n",
    "                if np.array_equal(complete_matrix[:,j], tmp_matrix[:,j]):\n",
    "                    control.append(1)                                                                    # 1 means True\n",
    "                else:\n",
    "                    control.append(0)                                                                    # 0 means True\n",
    "\n",
    "        if sum(control) == 0:\n",
    "            raise Exception(\"ERROR: Something went wrong in the function MoveToAnotherVertex.\")\n",
    "        else: \n",
    "            return complete_matrix\n",
    "    except:\n",
    "        raise Exception(\"ERROR: Something went wrong in the MoveToAnotherVertex. Please check the passed values.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "def Matrix_Primal2DualProblem(function_to_minimax, constraints):\n",
    "    \"\"\"\n",
    "    This function takes the parameters of the function to maximize (minimize) and the coefficients of constraints, both of type np.array. The last column of both arrays contains the bounds/values of the constraint/function. Primal2DualProble, returns the Dual Problem matrix (type: np.array) and the indices of base variables. \n",
    "    NB: I am fully aware that the nomenclature \"constraints_index\" for indicating the indices of base variables could be tricky, but it was useful to me when I wrote the first version of this code.\n",
    "    \n",
    "    Example:\n",
    "    INPUT: \n",
    "        max        z = 2x_1 + 3x_2 + 12x_3\n",
    "        subject to 4x_1 + 9x_2 + 0x_3 < 4\n",
    "                   5x_1 + 0x_2 + 1x_3 < 9\n",
    "        \n",
    "        function_to_minimax = np.array([[2, 3, 12, 0]]) \n",
    "        constraints         = np.array([[4, 9, 0 ,4],\n",
    "                                        [5, 0, 1, 9]])     \n",
    "    \n",
    "    OUTPUT \n",
    "    new_working_matrix      = np.array([[4, 9, 0, 1, 0 ,4],\n",
    "                                        [5, 0, 1, 0, 1, 9],\n",
    "                                        [2, 3, 12, 0, 0, 0]])  \n",
    "    new_constraints_index   = [3, 4]\n",
    "    \"\"\"\n",
    "    try:\n",
    "        tmp_working_matrix = np.vstack((constraints, function_to_minimax)) \n",
    "        new_working_matrix = np.zeros(np.shape(tmp_working_matrix.T))\n",
    "\n",
    "        # From Primal Matrix Probelm to Dual Matrix Problem\n",
    "        for i in range(len(new_working_matrix[:, 0])):\n",
    "            new_working_matrix[i, :] = tmp_working_matrix[:, i]\n",
    "\n",
    "        new_working_matrix[-1,:] = -new_working_matrix[-1,:]\n",
    "        new_constraints_index = list(range(len(new_working_matrix[0,:]) - 1, (len(new_working_matrix[0,:]) - 1 + len(new_working_matrix[:,0]) - 1)))\n",
    "\n",
    "        return new_working_matrix, new_constraints_index\n",
    "    except:\n",
    "        raise Exception(\"ERROR: Something went wrong in the Matrix_Primal2DualProbelm. Please check the passed values.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "def Solution_Dual2PrimalProblem(constraints, names_of_variables, names_of_variables_in_the_dual_solution, values_of_variables_in_the_dual_solution):\n",
    "    \"\"\"\n",
    "    This function takes the solutions of the Dual Problem and returns the solutions of the Primal one. It is necessary because my SimplexAlgorithm function uses the Duality Theorem to solve minimum problems.\n",
    "    NB: I am fully aware that the nomenclature \"constraints_index\" to indicate the indices of base variables could be tricky, but it was useful to me when I wrote the first version of this code.\n",
    "    \"\"\"\n",
    "    try:\n",
    "        # Variables\n",
    "        # MAX Problem (Dual)\n",
    "        dual_names_of_variables = names_of_variables \n",
    "        dual_names_of_constraints = names_of_variables_in_the_dual_solution\n",
    "        dual_values_of_variables = values_of_variables_in_the_dual_solution\n",
    "        # dual_intial_constraints_index = initial_constraints_index\n",
    "        # MIN Probelm (Primal)\n",
    "        primal_constraints = constraints\n",
    "\n",
    "\n",
    "        # From the Dual to the Primal solutions\n",
    "        primal_names_of_variables = list()\n",
    "        for i in range(len(dual_names_of_variables)):\n",
    "            var_dual = dual_names_of_variables[i]\n",
    "            xs = var_dual[0]\n",
    "            n = var_dual[1:]\n",
    "\n",
    "            if xs == \"x\":\n",
    "                xs = \"s\"\n",
    "            else:\n",
    "                xs = \"x\"\n",
    "            \n",
    "            var_dual = xs + n\n",
    "            primal_names_of_variables.append(var_dual)\n",
    "\n",
    "        # Sorted primal_names_of_variables and dual_names_of_variables\n",
    "        # primal_names_of_variables\n",
    "        def custom_sort_x(s):\n",
    "            if \"x\" in s:\n",
    "                return 0\n",
    "            elif \"s\" in s:\n",
    "                return 1\n",
    "            else:\n",
    "                return 2\n",
    "        primal_names_of_variables_sorted = sorted(primal_names_of_variables, key = custom_sort_x)\n",
    "        # dual_names_of_variables\n",
    "        def custom_sort_s(s):\n",
    "            if \"s\" in s:\n",
    "                return 0\n",
    "            elif \"x\" in s:\n",
    "                return 1\n",
    "            else:\n",
    "                return 2\n",
    "        dual_names_of_variables_inverted = sorted(dual_names_of_variables, key = custom_sort_s)\n",
    "\n",
    "\n",
    "        # Creating a dictionary, where keys are duals names of variables\n",
    "        primal2dual_vars_dict = {}\n",
    "        for x, y in zip(primal_names_of_variables_sorted, dual_names_of_variables_inverted):\n",
    "            primal2dual_vars_dict[x] = y\n",
    "\n",
    "        # Creating the working matrix (of the Primal Problem)\n",
    "        zeros_for_primal_matrix = np.eye(len(primal_constraints[:, 0]))\n",
    "        constraints_bounds_of_primal_problem = primal_constraints[:, [-1]]      \n",
    "        primal_working_matrix = primal_constraints[:, :-1]                                                        \n",
    "        primal_working_matrix = np.hstack((primal_working_matrix, -zeros_for_primal_matrix))\n",
    "        primal_working_matrix = np.hstack((primal_working_matrix, constraints_bounds_of_primal_problem)) \n",
    "\n",
    "        # Complete the base variable\n",
    "        dual_base_vars = list()\n",
    "        counter_values_of_constraints = 0\n",
    "        for i in range(len(dual_names_of_variables)):\n",
    "            if dual_names_of_variables[i] in dual_names_of_constraints:\n",
    "                dual_base_vars.append(dual_values_of_variables[counter_values_of_constraints])\n",
    "                counter_values_of_constraints += 1\n",
    "            else:\n",
    "                dual_base_vars.append(0)\n",
    "\n",
    "        # Applying Strong Duality Thoerem\n",
    "        tmp_index_of_rows = 0 \n",
    "        for i in range(len(dual_names_of_variables)):\n",
    "            if dual_base_vars[i] != 0:\n",
    "                tmp_index_of_col = dual_names_of_variables_inverted.index(primal2dual_vars_dict[primal_names_of_variables[i]])\n",
    "                primal_working_matrix[:, tmp_index_of_col] = 0\n",
    "                tmp_index_of_rows += 1\n",
    "\n",
    "        # Linear sistem (from Dual to Primal)\n",
    "        A = primal_working_matrix[:, :-1]                                                                                           # Coefficients\n",
    "        b = primal_working_matrix[:, -1]                                                                                            # Value\n",
    "\n",
    "        x, residuals, rank, s = np.linalg.lstsq(A, b, rcond=None)                                                                   # Solution of the linear system Ax = b\n",
    "\n",
    "        # Find the solution of the Primal Problem\n",
    "        values_of_variables_in_the_dual_solution = list()\n",
    "        names_of_variables_in_the_dual_solution = list()\n",
    "        for i in range(len(x)):\n",
    "            if x[i] != 0:\n",
    "                values_of_variables_in_the_dual_solution.append(round(x[i], 5))\n",
    "                names_of_variables_in_the_dual_solution.append(primal_names_of_variables_sorted[i])\n",
    "\n",
    "        return values_of_variables_in_the_dual_solution, names_of_variables_in_the_dual_solution\n",
    "    except:\n",
    "        raise Exception(\"ERROR: Something went wrong in the Solution_Dual2PrimalProblem. Please check the passed values.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "def SimplexAlgorithm(function_to_minimax, constraints, goal = \"max\"):\n",
    "    \"\"\"\n",
    "    This function takes the parameters of the function to maximize (minimize), the coefficients of constraints, both of type np.array, and whether it is a problem of maximization (goal = 'max') or minimization (goal = 'min'). The last column of both arrays contains the bounds/values of the constraint/function. The SimplexAlgorithm returns a Pandas DataFrame object which contains the maximum (minimum) value of the function, and the names and values of the base variables. Minimum problems are solved using the Duality Theorem.\n",
    "    NB: I am fully aware that the nomenclature \"constraints_index\" to indicate the indices of base variables could be tricky, but it was useful to me when I wrote the first version of this code.\n",
    "    \n",
    "    Example:\n",
    "    INPUT: \n",
    "        max        z = 2x_1 + 3x_2 + 12x_3\n",
    "        subject to 4x_1 + 9x_2 + 0x_3 < 4\n",
    "                   5x_1 + 0x_2 + 1x_3 < 9\n",
    "        \n",
    "        function_to_minimax = np.array([[2, 3, 12, 0]]) \n",
    "        constraints         = np.array([[4, 9, 0 ,4],\n",
    "                                        [5, 0, 1, 9]])     \n",
    "        goal                = 'max'\n",
    "    \n",
    "    OUTPUT \n",
    "    result = max value of the function          float\n",
    "             Names of base variables     [var1, var2]\n",
    "             Values of base variables    [int1, int2]\n",
    "    \"\"\"\n",
    "    try:\n",
    "        initial_goal = goal                                                                             # Save here the initial goal of the problem\n",
    "\n",
    "        # Creating the working matrix\n",
    "        if goal == \"max\":\n",
    "            working_matrix = np.vstack((constraints, -function_to_minimax))\n",
    "            constraints_index = list(range(len(working_matrix[0,:]) - 1, (len(working_matrix[0,:]) - 1 + len(working_matrix[:,0]) - 1)))\n",
    "        else:\n",
    "            if goal == \"min\":\n",
    "                working_matrix, constraints_index = Matrix_Primal2DualProblem(function_to_minimax, constraints)\n",
    "                goal = \"max\"\n",
    "            else: \n",
    "                raise Exception(\"ERROR: Please pass a valid value for the parameter goal ('max' or 'min')\")\n",
    "            \n",
    "        # Constraints saturation\n",
    "        zeros_of_constraints = np.eye(len(working_matrix[:, 0]) -1)\n",
    "        zeros_of_function_to_minimax = np.zeros((1, len(zeros_of_constraints[0,:])))\n",
    "        zeros = np.vstack((zeros_of_constraints, zeros_of_function_to_minimax))  \n",
    "\n",
    "        constraints_bounds = working_matrix[:, [-1]]                                                    # Constraint bounds and function value\n",
    "        working_matrix = working_matrix[:, :-1]                                                         # Coefficients of constraints and function\n",
    "\n",
    "        working_matrix = np.hstack((working_matrix, zeros))\n",
    "        working_matrix = np.hstack((working_matrix, constraints_bounds))                                # Definitive working matrix\n",
    "\n",
    "        # Names of variables and constraints    \n",
    "        names_of_variables = list()                                                                     # Where I will save the names of variables \n",
    "        names_of_constraints = list()                                                                   # Where I will save the names of base variables \n",
    "        counter_s = 1                                                                                   # Counter to count initial slacks\n",
    "        counter_x = 1                                                                                   # Counter to count intial variables\n",
    "        for i in range(len(working_matrix[0,:]) - 1):\n",
    "            if i in constraints_index:\n",
    "                names_of_variables.append(f\"s{counter_s}\")\n",
    "                names_of_constraints.append(f\"s{counter_s}\")\n",
    "                counter_s += 1\n",
    "            else:\n",
    "                names_of_variables.append(f\"x{counter_x}\")\n",
    "                counter_x += 1\n",
    "\n",
    "        # Shortly function to order names_of_variables and names_of_constraints, x comes before s.\n",
    "        def custom_sort_x(s):\n",
    "            if \"x\" in s:\n",
    "                return 0\n",
    "            elif \"s\" in s:\n",
    "                return 1\n",
    "            else:\n",
    "                return 2\n",
    "\n",
    "        names_of_variables = sorted(names_of_variables, key = custom_sort_x)\n",
    "        names_of_constraints = sorted(names_of_constraints, key = custom_sort_x)\n",
    "\n",
    "        z_line = working_matrix[-1, :]                                                            # Last line of working_matrix, which contains the values of the function\n",
    "        z_line_coeffs = z_line[:-1]                                                               # Coefficients of variables of the function\n",
    "        z_line_value = z_line[-1]                                                                 # Value of the function\n",
    "        values_of_variables = working_matrix[:-1, -1]                                             # Values of base variables\n",
    "\n",
    "        # Find the max (min) of the function \n",
    "        while True:\n",
    "            # Check if the solution it is admissible\n",
    "            if any(values_of_variables < 0):\n",
    "                if initial_goal == \"max\":\n",
    "                    result = pd.DataFrame({\n",
    "                        f\"{initial_goal} value of the function\": [z_line_value],\n",
    "                        \"Names of base variables\": \"There are not admissible solution\",\n",
    "                        \"Values of base variables\": \"There are not admissible solution\"\n",
    "                    })\n",
    "                    break\n",
    "                else:\n",
    "                    if initial_goal == \"min\":                                                      # Due to Weak Duality Theorem\n",
    "                        result = pd.DataFrame({\n",
    "                            f\"{initial_goal} value of the function\": [z_line_value],\n",
    "                            \"Names of base variables\": \"Unbounded Optimal Solution\",\n",
    "                            \"Values of base variables\": \"Unbounded Optimal Solution\"\n",
    "                        })\n",
    "                        break\n",
    "                    else:\n",
    "                        raise Exception(\"ERROR: Please pass a valid value for the parameter goal ('max' or 'min')\")\n",
    "\n",
    "            # Find a new vertex with a bigger (smaller) value of the function\n",
    "            constraints_index, names_of_constraints = entryANDexit_criteria(working_matrix, constraints_index, names_of_variables, names_of_constraints)\n",
    "\n",
    "            if constraints_index == \"Unbounded Optimal Solution\":\n",
    "                if initial_goal == \"max\":\n",
    "                    result = pd.DataFrame({\n",
    "                        f\"{initial_goal} value of the function\": [z_line_value],\n",
    "                        \"Names of base variables\": \"Unbounded Optimal Solution\",\n",
    "                        \"Values of base variables\": \"Unbounded Optimal Solution\"\n",
    "                    })\n",
    "                    break\n",
    "                else:\n",
    "                    if initial_goal == \"min\":                                                         # Due to Weak Duality Theorem\n",
    "                        result = pd.DataFrame({\n",
    "                            f\"{initial_goal} value of the function\": [z_line_value],\n",
    "                            \"Names of base variables\": \"There are not admissible solution\",\n",
    "                            \"Values of base variables\": \"There are not admissible solution\"\n",
    "                        })\n",
    "                        break\n",
    "\n",
    "\n",
    "            working_matrix = MoveToAnotherVertex(working_matrix, constraints_index)\n",
    "\n",
    "            z_line = working_matrix[-1, :]                                                            # Last line of working_matrix, which contains the values of the function\n",
    "            z_line_coeffs = z_line[:-1]                                                               # Coefficients of variables of the function\n",
    "            z_line_value = z_line[-1]                                                                 # Value of the function\n",
    "            values_of_variables = working_matrix[:-1, -1]                                             # Values of base variables\n",
    "\n",
    "            # Choose if we are in the maximum (minimum) point or not\n",
    "            continueORNOTcontinue = list()\n",
    "            for i in range(len(z_line_coeffs)):\n",
    "                if i in constraints_index:\n",
    "                    continue\n",
    "                else:\n",
    "                    if round(z_line_coeffs[i], 5) < 0 and goal == \"max\":\n",
    "                        continueORNOTcontinue.append(1)\n",
    "                    else:\n",
    "                        if round(z_line_coeffs[i], 5) > 0 and goal == \"max\":\n",
    "                            continueORNOTcontinue.append(0)\n",
    "                        else:\n",
    "                            if round(z_line_coeffs[i], 5) == 0:\n",
    "                                continueORNOTcontinue.append(\"inf\")\n",
    "                            else:\n",
    "                                if goal == \"min\":\n",
    "                                    raise Exception(\"Something went wrong. This function solves minimization problems using the Duality Theorem.\")\n",
    "                    \n",
    "\n",
    "            # Infinite solution\n",
    "            if any(elemement == 'inf' for elemement in continueORNOTcontinue):\n",
    "                if initial_goal == \"max\":\n",
    "                    result = pd.DataFrame({\n",
    "                        f\"{initial_goal} value of the function\": [z_line_value],\n",
    "                        \"Names of base variables\": \"There are infinite solution\",\n",
    "                        \"Values of base variables\": \"There are infinite solution\"\n",
    "                    })\n",
    "                    break\n",
    "                else:  \n",
    "                    if initial_goal == \"min\":                                                           # Due to Weak Duality Theorem\n",
    "                        result = pd.DataFrame({\n",
    "                            f\"{initial_goal} value of the function\": [z_line_value],\n",
    "                            \"Names of base variables\": \"There are not admissible solution\",\n",
    "                            \"Values of base variables\": \"There are not admissible solution\"\n",
    "                        })\n",
    "                        break\n",
    "                    else:\n",
    "                        raise Exception(\"ERROR: Please pass a valid value for the parameter goal ('max' or 'min')\")\n",
    "            else:\n",
    "                # Finite solution\n",
    "                if initial_goal == \"max\":\n",
    "                    if sum(continueORNOTcontinue) == 0:\n",
    "                        result = pd.DataFrame({\n",
    "                            f\"{initial_goal} value of the function\": [z_line_value],\n",
    "                            \"Names of base variables\": [names_of_constraints],\n",
    "                            \"Values of base variables\": [values_of_variables]\n",
    "                        })\n",
    "                        break\n",
    "                else:\n",
    "                    if initial_goal == \"min\":\n",
    "                        if sum(continueORNOTcontinue) == 0:\n",
    "                            names_of_variables_in_the_dual_solution = names_of_constraints\n",
    "                            values_of_variables_in_the_dual_solution = values_of_variables\n",
    "                            values_of_variables_dual2primal, names_of_constraints_dual2primal = Solution_Dual2PrimalProblem(constraints, names_of_variables, names_of_variables_in_the_dual_solution, values_of_variables_in_the_dual_solution)\n",
    "\n",
    "                            result = pd.DataFrame({\n",
    "                                f\"{initial_goal} value of the function\": [z_line_value],\n",
    "                                \"Names of base variables\": [names_of_constraints_dual2primal],\n",
    "                                \"Values of base variables\": [values_of_variables_dual2primal]\n",
    "                            })\n",
    "                            break\n",
    "                    else:\n",
    "                        raise Exception(\"ERROR: Please pass a valid value for the parameter goal ('max' or 'min')\")\n",
    "\n",
    "        result = result.T\n",
    "        return result\n",
    "    except:\n",
    "        raise Exception(\"ERROR: Something went wrong in the SimplexAlgorithm. Please check the passed values.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### I/O Knapsack Problem using Branch and Bound Algotithm\n",
    "The following function solves the famous Knapsack Problem using the Branch and Bound Algorithm. It takes the following inputs:           \n",
    "- *weights* (as a list), representing the space required by each object *i*;            \n",
    "- *utility* (as a list), representing the importance of each object *i*;            \n",
    "- *capacity* (as an integer), representing the total space available in the knapsack;       \n",
    "\n",
    "The function finds the combination of objects that maximize the utility, based on the fundamental hypothesis that utility is additive. Specifically, the function returns a Pandas DataFrame that includes which objects are included in the knapsack, the total utility, and the amount of used capacity.\n",
    "\n",
    "The *KnapsackProblem* function calls two other functions:       \n",
    "- *find_the_branches*: given the capacity, a Pandas DataFrame with initial weights and utility values, and a constraint on weights (e.g., if during the previous branch we chose to include object 2, the constraint would be represented as x1xxx..xxx; otherwise, it would be x0xxx...xxx), this function calculates the maximum total utility, modifies the constraints and weights, and indicates whether a node can be further branched (ok_na = 0) or not (ok_na = 1). All of this information are returned in a Pandas DataFrame;                   \n",
    "- *get_my_index*: a simple function that finds where in a DataFrame the values in column 1 meet condition 1 and the values in column 2 meet condition 2.        \n",
    "\n",
    "**Note**: Although this function is based on the knapsack problem, it can easily be adapted for other problems, such as deciding whether to include or exclude a security in a portfolio (under the assumption that we cannot choose to partially include a security in our portfolio) with the goal of maximizing the portfolio value.         \n",
    "\n",
    "**Example**         \n",
    "Give the problem:\n",
    "\n",
    "$$\n",
    "\\begin{array}{|c|c|c|c|c|c|}\n",
    "    \\hline\n",
    "    \\textbf{Objects} & A & B & C & D & E \\\\\n",
    "    \\hline\n",
    "    \\textbf{Weights} & 25 & 40 & 30 & 50 & 50 \\\\\n",
    "    \\hline\n",
    "    \\textbf{Utility} & 28 & 48 & 37 & 62 & 59 \\\\\n",
    "    \\hline\n",
    "    \\textbf{Capacity} & 130 & & & & \\\\\n",
    "    \\hline\n",
    "\\end{array}\n",
    "$$\n",
    "\n",
    "The *KnapsackProblem* function takes as input:               \n",
    "```python\n",
    "weights = [25, 40, 30, 50, 50]\n",
    "utility = [28, 48, 37, 62, 59]\n",
    "capacity = 130\n",
    "```\n",
    "And the output will be:     \n",
    "```python\n",
    "             Weights              Obj  Utility  Used capacity (%)\n",
    "0  [1, 1, 0.0, 1, 0]  [4, 3, 2, 5, 1]    158.0              100.0\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "def find_the_branches(constraints, df, capacity):\n",
    "    \"\"\"\n",
    "    Given the capacity, a Pandas DataFrame with initial weights and utility values, and a constraint on weights (e.g., if during the previous branch we chose to include object 2, the constraint would be represented as x1xxx..xxx; otherwise, it would be x0xxx...xxx), this function calculates the maximum total utility, modifies the constraints and weights, and indicates whether a node can be further branched (ok_na = 0) or not (ok_na = 1). All of this information is returned in a Pandas DataFrame.\n",
    "    \"\"\"\n",
    "    try:\n",
    "        # Setting the variables \n",
    "        branch_sum = 0 \n",
    "        branch_weights = [0] * len(df.loc[\"Weights\", ])\n",
    "        total_utility = 0\n",
    "\n",
    "        # Initial sum, consider the constraints \n",
    "        for j_indices1 in range(len(constraints)):\n",
    "            if constraints[j_indices1] == 1:\n",
    "                branch_sum = branch_sum + df.loc[\"Weights\", ][j_indices1]\n",
    "                branch_weights[j_indices1] = 1\n",
    "\n",
    "        # Check if the initial sum is less than capacity, otherwise stop the code and return \"NA\"\n",
    "        if branch_sum > capacity:\n",
    "            return \"NA\"\n",
    "        else:\n",
    "            for j_branches in range(len(df.loc[\"Weights\", ])):\n",
    "                # Skip if there're a 0 or a 1 (I've yet consider if there's a 1)\n",
    "                if (constraints[j_branches] == 0) or (constraints[j_branches] == 1):\n",
    "                    continue\n",
    "                else:\n",
    "                    branch_sum = branch_sum + df.loc[\"Weights\", ][j_branches]\n",
    "                    branch_weights[j_branches] = 1\n",
    "                    \n",
    "                    if branch_sum > capacity:\n",
    "                        branch_sum = branch_sum - df.loc[\"Weights\", ][j_branches]\n",
    "                        branch_weights[j_branches] = ((capacity) - branch_sum)/df.loc[\"Weights\", ][j_branches]\n",
    "                        branch_sum = branch_sum + ((capacity) - branch_sum)\n",
    "                        break\n",
    "\n",
    "        for j_utility in range(len(branch_weights)):\n",
    "            total_utility = total_utility + (df.loc[\"Utility\", ][j_utility] * branch_weights[j_utility])\n",
    "\n",
    "        # Check if the solution is assertable or not\n",
    "        if sum(branch_weights) % 1 == 0:\n",
    "            ok_na = 1\n",
    "        else:\n",
    "            ok_na = 0\n",
    "            \n",
    "        result = pd.DataFrame({\n",
    "            \"Constraint\": [constraints],\n",
    "            \"Weights\": [branch_weights],\n",
    "            \"Utility\": total_utility,\n",
    "            \"Used capacity (%)\": (branch_sum/capacity)*100,\n",
    "            \"OK\": ok_na\n",
    "        }).T     \n",
    "\n",
    "        return result\n",
    "    except:\n",
    "        raise Exception(\"ERROR: Something went wrong. Please pass valid values for the parameters\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_my_index(df, condition1, col_name_condition1, condition2, col_name_condition2):\n",
    "    \"\"\"\n",
    "    A simple function that finds where in a DataFrame the values in column 1 meet condition 1 and the values in column 2 meet condition 2.\n",
    "    NB: this functions works only with equality conditions (i.e. df[col_name_condition1][i] == condition1 works, but df[col_name_condition1][i] < condition1 does not work).\n",
    "    \"\"\"\n",
    "    try:\n",
    "        for i in range(len(df[col_name_condition1])):\n",
    "            if (df[col_name_condition1][i] == condition1) and (df[col_name_condition2][i] == condition2):\n",
    "                return i\n",
    "    except:\n",
    "        raise Exception(\"ERROR: Something went wrong. Please pass valid values for the parameters\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "def KnapsackProblem(weights, utility, capacity):\n",
    "    \"\"\" \n",
    "    The following function solves the famous Knapsack Problem using the Branch and Bound Algorithm. It takes the following inputs:\n",
    "    - weights (as a list), representing the space required by each object *i*;            \n",
    "    - utility (as a list), representing the importance of each object *i*;            \n",
    "    - capacity (as an integer), representing the total space available in the knapsack;       \n",
    "\n",
    "    The function finds the combination of objects that maximise the utility, based on the fundamental hypothesis that utility is additive. Specifically, the function returns a Pandas DataFrame that includes which objects are included in the knapsack, the total utility, and the amount of used capacity.\n",
    "    \"\"\"\n",
    "    try:\n",
    "        # PREMILIMARY OPERATIONS\n",
    "        # Creating the DataFrame and ordering objects by u/w ratio. \n",
    "        uw_ratio = [utility[i]/weights[i] for i in range(len(weights))]                                            # Utility per weight ratio\n",
    "\n",
    "        obj = range(1, len(weights) + 1)                                                                           # \"Names\" of objects\n",
    "\n",
    "        df = pd.DataFrame(columns = ['Obj', 'Weights', 'Utility', 'U/W ratio'])\n",
    "\n",
    "        for i_constraint in range(len(weights)):\n",
    "            tmp = pd.DataFrame({\n",
    "                'Obj': [obj[i_constraint]],\n",
    "                'Weights': [weights[i_constraint]],\n",
    "                'Utility': [utility[i_constraint]],\n",
    "                'U/W ratio': [uw_ratio[i_constraint]]\n",
    "            })\n",
    "\n",
    "            df = pd.concat([df, tmp], ignore_index = True)\n",
    "\n",
    "        df  = df.T                                                                                                 # Just for My Convenience\n",
    "        df_orderly = df.sort_values(by = \"U/W ratio\", axis = 1, ascending = False, ignore_index = True)            # Ordering objects by u/w ratio. \n",
    "\n",
    "\n",
    "        # UPPER BOUND\n",
    "        # Finding the upper bound\n",
    "        constraint = [\"x\"]*len(weights)                                                                             # Initial constraint (\"x\" means that there are not constaints)\n",
    "\n",
    "        upperbound = find_the_branches(constraint, df_orderly, capacity)\n",
    "        upperbound_weights = (upperbound.loc[\"Weights\", ])[0]\n",
    "        utility = upperbound.loc[\"Utility\", ]\n",
    "\n",
    "        # Creating a dataframe where I'll save the results\n",
    "        branches = pd.DataFrame(columns = [\"Constraint\", \"Weights\", \"Utility\", \"OK\"])\n",
    "        # Saving the values of the upper bound\n",
    "        upperbound_df = pd.DataFrame({\n",
    "            \"Constraint\": [constraint],\n",
    "            \"Weights\": [upperbound_weights],\n",
    "            \"Utility\": utility,\n",
    "            \"OK\": upperbound.loc[\"OK\"],\n",
    "            \"Used capacity (%)\": upperbound.loc[\"Used capacity (%)\"],\n",
    "            \"BranchOff\": \"No\"\n",
    "        })\n",
    "        branches = pd.concat([branches, upperbound_df], ignore_index = True)\n",
    "\n",
    "\n",
    "        # BRANCHES \n",
    "        options = [0, 1]                                                                                            # Options for the constraints: each times I've to check if the decimal number could be 0 or 1 \n",
    "        counter_cylces = 0                                                                                          # If the cycles will be more than 10^5, I'll stop the code and return the default result\n",
    "        result = \"There is not a integer solution\"                                                                  # Defual result\n",
    "        \n",
    "        while True:\n",
    "            # Get the number of node with highest utility and that is not branch off yet \n",
    "            max_utility = branches.query(\"BranchOff == 'No'\")['Utility'].max()\n",
    "            index_of_branch = get_my_index(branches, max_utility, \"Utility\", \"No\", \"BranchOff\")\n",
    "            \n",
    "            weights_tmp = branches[\"Weights\"][index_of_branch]\n",
    "            constraint_tmp = branches[\"Constraint\"][index_of_branch]\n",
    "\n",
    "            if sum(weights_tmp) % 1 == 0:                                                                           # If the sum of final_weigths has no remainder means that we've find the optimal solution \n",
    "                break\n",
    "            else: \n",
    "                for i_constraint in range(len(weights_tmp)):\n",
    "                    if not((weights_tmp[i_constraint] == 1) or (weights_tmp[i_constraint] == 0)):                   # If the value in the position i is not 1 or 0 means that we've find where branch off \n",
    "                        for i_options in range(len(options)):\n",
    "                            new_constraint_tmp = constraint_tmp.copy()\n",
    "                            new_constraint_tmp[i_constraint] = options[i_options]\n",
    "                            branch_tmp = find_the_branches(new_constraint_tmp, df_orderly, capacity)\n",
    "\n",
    "                            if type(branch_tmp) == str:                                                             # If find_the_branches returns \"NA\" (a string) means that there is not a branch available\n",
    "                                continue                    \n",
    "\n",
    "                            newrow = pd.DataFrame({\n",
    "                                \"Constraint\": [new_constraint_tmp],\n",
    "                                \"Weights\": [(branch_tmp.loc[\"Weights\", ])[0]],\n",
    "                                \"Utility\": branch_tmp.loc[\"Utility\", ],\n",
    "                                \"OK\": branch_tmp.loc[\"OK\"],\n",
    "                                \"Used capacity (%)\": branch_tmp.loc[\"Used capacity (%)\"],\n",
    "                                \"BranchOff\": \"No\"\n",
    "                            })\n",
    "                            branches = pd.concat([branches, newrow], ignore_index = True)\n",
    "\n",
    "                        branches[\"BranchOff\"][index_of_branch] = \"Yes\"                                              # Say that this node is branched off\n",
    "            \n",
    "            # If cycles are more than 10^5, stop the code\n",
    "            counter_cylces +=1\n",
    "            if(counter_cylces> 10*5):\n",
    "                return result\n",
    "            \n",
    "            # Get the result\n",
    "            if any(branches[\"OK\"] == 1):\n",
    "                # Branches admissible and not admissible\n",
    "                branches_ok = branches[branches['OK'] == 1]\n",
    "                branches_ok = branches_ok.reset_index(drop = True)\n",
    "                branches_na = branches[(branches['OK'] == 0) & (branches['BranchOff'] == 'No')]\n",
    "\n",
    "                max_utility_OK = branches_ok[\"Utility\"].max()\n",
    "                max_utility_NA = branches_na[\"Utility\"].max()\n",
    "\n",
    "                tmp_result = list(branches_ok[\"Utility\"])\n",
    "                index_of_result = tmp_result.index(max_utility_OK)\n",
    "\n",
    "                result = pd.DataFrame({\n",
    "                    \"Weights\": [branches_ok[\"Weights\"][index_of_result]],\n",
    "                    \"Obj\": [list(df_orderly.loc[\"Obj\",:].astype(int))],\n",
    "                    \"Utility\": [branches_ok[\"Utility\"][index_of_result]],\n",
    "                    \"Used capacity (%)\": [branches_ok[\"Used capacity (%)\"][index_of_result]],\n",
    "                })\n",
    "                \n",
    "                if float(max_utility_OK) >= float(max_utility_NA):\n",
    "                    break \n",
    "                else:\n",
    "                    continue\n",
    "        \n",
    "        return result\n",
    "    except:\n",
    "        raise Exception(\"ERROR: Something went wrong. Please pass valid values for the parameters\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Dynamic Models\n",
    "- Consensus Dynamic Model        \n",
    "- Linear Dynamic Population Redistribution Model        "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here I report the theory on which the two models are based."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Consensus Dynamic Model**  \n",
    "The Consensus Dynamic Model (in a popolutaion of $n \\geq 2$ individuals) is based on the following equation:\n",
    "$$\n",
    "x_t = Cx_{t-1}\\,\\,\\,\\,\\,\\,\\forall t > 0\n",
    "$$\n",
    "where $x_t$ is a vector which represents the opinion of individuals.    \n",
    "The transition matrix $C$ determine the time-invariant weighting mechanism that describes the revision of individual opinions in each iteration of the model. It is assumed that the transition matrix $C$, a square matrix of order $n$, is positive, simple (there exists a basis of eigenvectors), and row-stochastic.\n",
    "\n",
    "Each element of the transition matrix $c_{ij} \\in (0,1)$ represents the influential weight that individual $i$ assigns to the opinion of individual $j$ when revising and updating their own opinion, with $i, j = 1, \\ldots, n$. In this model, the transition matrix $C$ is constructed based on the interaction matrix $V = [v_{ij}]$ and the vector $u = (u_1, \\ldots, u_n)$ of individual propensities $u_i \\in (0, 1)$ to revise their opinions, with $i = 1, \\ldots, n$. The diagonal of the interaction matrix is zero, and each off-diagonal element $v_{ij} \\in (0, 1)$ with $i \\neq j$ represents the degree of authority that individual $i$ attributes to individual $j$.\n",
    "\n",
    "The solution path of the dynamic model involves, in addition to the construction of the transition matrix $C$, the determination of the asymptotic solution indicated by the vector $x(t = \\infty)$, which represents the convergence of the linear dynamics toward a stable profile of the opinions of the $n$ individuals.\n",
    "\n",
    "Considering that the dominant right eigenvector of the transition matrix is $r = (1/n, \\ldots, 1/n)$, the only stable solutions are those consensual ones, where all opinions are aligned to the same consensual opinion. Denoting the invariant scalar of the dynamic model by $\\tilde{x} = s^T x$, where $s$ is the dominant left eigenvector of the transition matrix, and knowing that the asymptotic solution is a multiple of the dominant right eigenvector $r$, we can use the fact that $s^T r = 1/n$ to conclude that the linear dynamics asymptotically converge to the stable profile $x(t = \\infty) = n\\tilde{x}r = (\\tilde{x}, \\ldots, \\tilde{x})$, where the invariant scalar $\\tilde{x} = s^T x$ corresponds to the asymptotic consensual opinion.\n",
    "\n",
    "Finally, since the asymptotic consensual opinion can be calculated by directly weighting the initial opinions with the components of the dominant left eigenvector, $\\tilde{x} = s^T x(t = 0)$, the components of $s$ indicate the relative importance that each of the $n$ individuals had in determining the value of the consensual opinion."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Linear Dynamic Population Redistribution Model**      \n",
    "Consider the linear dynamic model of redistribution of a population of $N \\geq 2$ individuals over $n \\geq 2$ types of residential areas: for example, with $n = 3$, the areas are urban ($i = 1$), suburban ($i = 2$), and rural ($i = 3$). The distribution of individuals among the $n$ residential areas is indicated by the vector \n",
    "\n",
    "$$x(t) = (x_1(t), \\ldots, x_n(t))\\,\\,\\,\\,\\,\\,\\forall t \\geq 0$$\n",
    "\n",
    "where $x_i(t)$ denotes the number of individuals residing in area $i = 1, \\ldots, n$ at time $t = 0, 1, 2, \\ldots$, always maintaining \n",
    "\n",
    "$$x_1(t) + \\ldots + x_n(t) = N.$$\n",
    "\n",
    "The linear redistribution dynamics for residential areas, expressed by the iterative law \n",
    "\n",
    "$$x(t) = Cx(t-1)\\,\\,\\,\\,\\,\\,\\forall t \\geq 0$$\n",
    "\n",
    "aims to represent the change in the population distribution across the $n$ residential areas due to the annual transfer of individuals from one residential area to another, starting from an initial distribution $x(t = 0)$.\n",
    "\n",
    "The transition matrix $C = [c_{ij}]$ of the linear dynamics describes the time-invariant pattern of these annual transfers of individuals from one residential area to another. It is assumed that the transition matrix $C$, a square matrix of order $n$, is positive, simple (there exists a basis of eigenvectors), and column-stochastic. Each element of the transition matrix, $c_{ij} \\in (0,1)$, represents the fraction of residents in area $j$ that transfer each year to area $i$, with $i, j = 1, \\ldots, n$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 109,
   "metadata": {},
   "outputs": [],
   "source": [
    "def DynamicModels(matrix, x_t0, x_tn, type_of_model, u = None, N = None):\n",
    "    \"\"\"\n",
    "    This function resolves two types of Dynamic Models seen in class: the Consensus Dynamics Model and the Linear Dynamic Population Redistribution Model. It takes as input:\n",
    "    - a matrix (np.array) representing V in the case of the Consensus Dynamics Model or C in the case of the Linear Dynamic Population Redistribution Model;\n",
    "    - a vector (list) representing x(t0);\n",
    "    - an integer value for t representing the time step for the finite solution (e.g., if we want to compute x(t10), then t will be 10);\n",
    "    - type_of_model: \"cd\" for the Consensus Dynamics Model or \"pop\" for the Linear Dynamic Population Redistribution Model;\n",
    "    - a vector (list) representing u in the case of the Consensus Dynamics Model, or an integer N in the case of the Linear Dynamic Population Redistribution Model.\n",
    "    \"\"\"\n",
    "    try:\n",
    "        result = pd.DataFrame(columns = [\"Asymptotic solution\", f\"x_t{x_tn}\", \"Dominant eigenvector\"])\n",
    "\n",
    "        # Linear Dynamic Population Redistribution Model\n",
    "        if type_of_model == \"pop\":\n",
    "            # Computing and sorting eigenvalues, eigenvectors\n",
    "            eigenvalues, eigenvectors = np.linalg.eig(matrix) # (right eigenvectors)\n",
    "            indices = np.argsort(eigenvalues)[::-1]  \n",
    "            eigenvalues = eigenvalues[indices]\n",
    "            eigenvectors = eigenvectors[:, indices]\n",
    "\n",
    "            if round(eigenvalues[0], 5) == 1:\n",
    "                # Asymptotic solution\n",
    "                r = eigenvectors[:,0] / sum(eigenvectors[:,0]) \n",
    "                asymptotic_solution = N * r\n",
    "\n",
    "                # Solution at t_n\n",
    "                x_tminus1 = x_t0\n",
    "                for i in range(x_tn):\n",
    "                    x_t = np.matmul(matrix, x_tminus1)\n",
    "                    x_tminus1 = x_t\n",
    "\n",
    "                # Return the initial matrix\n",
    "                return_matrix = matrix\n",
    "                dominant_eigenvector = r\n",
    "            else:\n",
    "                print(\"ERROR: The matrix you provided does not have an eigenvalue equal to 1.\")\n",
    "        else:\n",
    "            # Consensus Dynamics Model\n",
    "            if type_of_model == \"cd\":\n",
    "                # Transition matrix C\n",
    "                transition_matrix = np.empty((len(matrix[:,0]), len(matrix[0])))\n",
    "                for i in range(len(matrix[:,0])):\n",
    "                    for j in range(len(matrix[0])):\n",
    "                        if i == j:\n",
    "                            transition_matrix[i, j] = 1 - u[i]\n",
    "                        else:\n",
    "                            transition_matrix[i, j] = u[i] * (matrix[i, j]/sum(matrix[i]))\n",
    "\n",
    "                # Asymptotic solution\n",
    "                eigenvectors = eigeinvectors_calculator(transition_matrix, \"left\")\n",
    "                # Get the index where eigenvalue equals to 1\n",
    "                eigenvalues = eigenvectors[\"Eigenvalue\"]\n",
    "                for z in range(len(eigenvalues)):\n",
    "                    if math.isclose(eigenvalues[z][0], 1):\n",
    "                        index_eigenvalues = z\n",
    "                        break\n",
    "                # Get the eigenvector which corresponds to eigenvalue 1\n",
    "                s = list()\n",
    "                for i in range(eigenvectors[\"Eigenvector\"][0][0].shape[0]):\n",
    "                    s.append(eigenvectors.iloc[index_eigenvalues, 1][0][i][0])\n",
    "                s = s / sum(s)\n",
    "\n",
    "                asymptotic_solution = [round(np.dot(s, x_t0), 5)] * len(x_t0)\n",
    "                dominant_eigenvector = s\n",
    "                \n",
    "                # Solution at t_n\n",
    "                x_tminus1 = x_t0\n",
    "                for i in range(x_tn):\n",
    "                    x_t = np.matmul(transition_matrix, x_tminus1)\n",
    "                    x_tminus1 = x_t\n",
    "\n",
    "                # Return the transition matrix\n",
    "                return_matrix = transition_matrix\n",
    "\n",
    "        # Result\n",
    "        dominant_eigenvector = [round(num, 5) for num in dominant_eigenvector]\n",
    "        newrow = {\"Asymptotic solution\" : np.around(asymptotic_solution, 5), f\"x_t{x_tn}\": np.around(x_t, 5), \"Dominant eigenvector\" : dominant_eigenvector}\n",
    "        result.loc[len(result)] = newrow\n",
    "\n",
    "        return result, return_matrix\n",
    "    except:\n",
    "        raise Exception(\"ERROR: Something went wrong. Please pass valid values for the parameters\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Test"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Introductory matrix algebra"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 114,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The MatrixPlusMatrix function works correctly\n",
      "The MatrixTimesMatrix function works correctly\n",
      "The Determinant function works correctly\n",
      "The InverseMatrix function works correctly\n",
      "The Minor function works correctly\n",
      "The Rank function works correctly\n",
      "The CheckDiagonal function works correctly\n",
      "The GuassianElimination function works correctly\n",
      "The SolveLinearSystem function works correctly\n",
      "The eigeinvectors_calculator function works correctly\n"
     ]
    }
   ],
   "source": [
    "# Addition of two matrices\n",
    "m1 = np.array([[1,2,3],[4,5,6]])\n",
    "m2 = np.array ([[0,-1,2], [-2,1,0]])\n",
    "assert np.array_equal(matrixplusmatrix(m1,m2), (m1 + m2))\n",
    "print(\"The MatrixPlusMatrix function works correctly\")\n",
    "\n",
    "# Multiplication of two matrices\n",
    "m3 = np.array([[2, -1], [0,1]])\n",
    "m4 = np.array([[1,2,3], [3,1,0]])\n",
    "assert np.array_equal(matrixtimesmatrix(m3,m4), np.dot(m3,m4))                  \n",
    "print(\"The MatrixTimesMatrix function works correctly\")\n",
    "\n",
    "# Determinant of a matrix\n",
    "m5 = np.array([[0]])\n",
    "m6 = np.array([[2,4], [1,2]])\n",
    "m7 = np.array ([[1,-1,-4], [3,1,-1], [5,3,2]])\n",
    "m8 = np.array([[2,6,-2,2], [-2,4,0,3], [-3,1,1,2], [1,3,-1,2]])\n",
    "assert determinant(m5) == round(np.linalg.det(m5),2) #1x1\n",
    "assert determinant(m6) == round(np.linalg.det(m6),2) #2x2\n",
    "assert determinant(m7) == round(np.linalg.det(m7),2) #Sarrus\n",
    "assert determinant(m8) == round(np.linalg.det(m8),2) #4x4\n",
    "print(\"The Determinant function works correctly\")\n",
    "\n",
    "# Inverse of a matrix\n",
    "m9 = np.array([[1,3,4], [1,1,4], [-1,0,1]])\n",
    "assert np.allclose(inversematrix(m9), np.linalg.inv(m9))\n",
    "print(\"The InverseMatrix function works correctly\")\n",
    "\n",
    "# Minor of a matrix\n",
    "m10 = np.array([[1,0,-1,2],[-1,1,-2,0],[-2,-1,1,2]])\n",
    "assert len(minor(m10)) == 34\n",
    "assert len(minor(m10, order = 1)) == 12\n",
    "assert len(minor(m10, order = 2)) == 18\n",
    "assert len(minor(m10, order = 3)) == 4\n",
    "print(\"The Minor function works correctly\")\n",
    "\n",
    "# Rank of a matrix\n",
    "m11 = np.array([[1,-2,0],[0,1,1],[-1,3,1]])\n",
    "m12 = np.array([[2,6,-2,2], [-2,4,0,3], [-3,1,1,2], [1,3,-1,1]])\n",
    "m13 = np.array([[1,0,-1,2],[-1,1,-2,0],[2,-1,1,2]])\n",
    "assert rank(m11) == np.linalg.matrix_rank(m11)\n",
    "assert rank(m12) == np.linalg.matrix_rank(m12)\n",
    "assert rank(m13) == np.linalg.matrix_rank(m13)\n",
    "print(\"The Rank function works correctly\")\n",
    "\n",
    "# Gaussian elimination method for solving a linear system\n",
    "# Check diagonal\n",
    "assert check_diagonal(np.array([[1, 1, 1], [0, 1, 2], [0, 0, 2]])) == True\n",
    "assert check_diagonal(np.array([[1, 1, 1], [0, 1, 2], [0, 1, 2]])) == False\n",
    "assert check_diagonal(np.array([[0, 1, 1], [0, 1, 2], [0, 1, 2]])) == False\n",
    "assert check_diagonal(np.array([[1, 1, 1], [0, 0, 2], [0, 1, 2]])) == False\n",
    "assert check_diagonal(np.array([[1, 1, 1], [0, 1, 2], [0, 0, 0]])) == True\n",
    "print(\"The CheckDiagonal function works correctly\")\n",
    "# Gaussian elimination method for solving a linear system\n",
    "m14 = np.array([[1,-1,4],[3,1,-1],[5,3,2]])\n",
    "m15 = np.array([[0],[3],[6]])\n",
    "assert np.array_equal(guassian_elimination(m14, m15), np.array([[1, -1, 4, 0], [0, 1, -3.25, 0.75], [0, 0, 0, 0]]))\n",
    "print(\"The GuassianElimination function works correctly\")\n",
    "# Solve a linear system\n",
    "assert solve_linearsystem(m14, m15) == [\"x1 = ['-1.0x2' '4.0x3' 0.0]\", \"x2 = ['-3.25x3' 0.75]\"] \n",
    "print(\"The SolveLinearSystem function works correctly\")\n",
    "\n",
    "# Eigenvectors\n",
    "matrix = np.array([[1, -2, 2],  \n",
    "                   [-1, 2, 1],\n",
    "                   [0, 0, -1]])\n",
    "\n",
    "eigeinvectors_right = eigeinvectors_calculator(matrix, \"right\")\n",
    "alpha1r = 1/(eigeinvectors_right[\"Eigenvector\"][0][0][0] * 0.5)\n",
    "alpha2r = -1/(eigeinvectors_right[\"Eigenvector\"][1][0][0])\n",
    "alpha3r = -1/(eigeinvectors_right[\"Eigenvector\"][2][0][0] * 0.5)\n",
    "assert np.allclose((eigeinvectors_right[\"Eigenvector\"][0])[0]*alpha1r, np.array([[2], [1], [0]]), atol=0.01, rtol=0.01) == True\n",
    "assert np.allclose((eigeinvectors_right[\"Eigenvector\"][1])[0]*alpha2r, np.array([[-1], [1], [0]]), atol=0.01, rtol=0.01) == True\n",
    "assert np.allclose((eigeinvectors_right[\"Eigenvector\"][2])[0]*alpha3r, np.array([[-2], [-1], [1]]), atol=0.01, rtol=0.01) == True\n",
    "\n",
    "eigeinvectors_left = eigeinvectors_calculator(matrix, \"left\")\n",
    "alpha1l = 1/(eigeinvectors_left[\"Eigenvector\"][0][0][0])\n",
    "alpha2l = -1/(eigeinvectors_left[\"Eigenvector\"][1][0][0])\n",
    "assert np.allclose((eigeinvectors_left[\"Eigenvector\"][0])[0]*alpha1l, np.array([[1], [1], [3]]), atol=0.01, rtol=0.01) == True\n",
    "assert np.allclose((eigeinvectors_left[\"Eigenvector\"][1])[0]*alpha2l, np.array([[-1], [2], [0]]), atol=0.01, rtol=0.01) == True\n",
    "assert np.allclose((eigeinvectors_left[\"Eigenvector\"][2])[0], np.array([[0], [0], [1]]), atol=0.01, rtol=0.01) == True\n",
    "\n",
    "print(\"The eigeinvectors_calculator function works correctly\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Linear programming"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 115,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The function SimplexAlgorithm work correctly when goal == 'max'\n",
      "The function SimplexAlgorithm work correctly when goal == 'min'\n",
      "The KnapsackProblem function works correctly\n"
     ]
    }
   ],
   "source": [
    "# Simplex Algorithm\n",
    "# MAX\n",
    "function_to_minimax = np.array([[6, 2, 4, 0]])\n",
    "constraints = np.array([[1, 2, 3, 60],\n",
    "                        [2, 1, 1, 30]])\n",
    "assert SimplexAlgorithm(function_to_minimax, constraints, \"max\").iloc[0,0] == 108\n",
    "assert np.array_equal(SimplexAlgorithm(function_to_minimax, constraints, \"max\").iloc[2,0], [6, 18])\n",
    "\n",
    "function_to_minimax = np.array([[-1, 2, 0]])\n",
    "constraints = np.array([[-1, 2, 10],\n",
    "                        [1, 1, 11],\n",
    "                        [4, -7, 0]])\n",
    "assert SimplexAlgorithm(function_to_minimax, constraints, \"max\").iloc[0,0] == 10\n",
    "assert SimplexAlgorithm(function_to_minimax, constraints, \"max\").iloc[2,0] == \"There are infinite solution\"\n",
    "\n",
    "function_to_minimax = np.array([[6, 4, 15, 0]])\n",
    "constraints = np.array([[3, 1, 5, 4],\n",
    "                        [1, 1, 3, 5]])\n",
    "assert SimplexAlgorithm(function_to_minimax, constraints, \"max\").iloc[0,0] == 16\n",
    "assert np.array_equal(SimplexAlgorithm(function_to_minimax, constraints, \"max\").iloc[2,0], [4, 1])\n",
    "\n",
    "# Ottimo illimitato (vedi appunti)\n",
    "\n",
    "function_to_minimax = np.array([[1, 1, 0]])\n",
    "constraints = np.array([[-4, 1, 3],\n",
    "                        [2, -1, 6]])\n",
    "assert SimplexAlgorithm(function_to_minimax, constraints, \"max\").iloc[0,0] == 3\n",
    "assert SimplexAlgorithm(function_to_minimax, constraints, \"max\").iloc[2,0] == \"Unbounded Optimal Solution\"\n",
    "\n",
    "function_to_minimax = np.array([[1, -1, 0]])\n",
    "constraints = np.array([[1, 1, 5],\n",
    "                        [1, -2, 2],\n",
    "                        [0, 2, 3]])\n",
    "assert SimplexAlgorithm(function_to_minimax, constraints, \"max\").iloc[0,0] == 3\n",
    "assert np.array_equal(SimplexAlgorithm(function_to_minimax, constraints, \"max\").iloc[2,0], [4, 1, 1])\n",
    "\n",
    "print(\"The function SimplexAlgorithm work correctly when goal == 'max'\")\n",
    "\n",
    "# MIN\n",
    "function_to_minimax = np.array([[8, 4, 1, 0]])\n",
    "constraints = np.array([[1, -1, 1, 1],\n",
    "                        [1, 1, 0, 3]])\n",
    "assert SimplexAlgorithm(function_to_minimax, constraints, \"min\").iloc[0,0] == 16\n",
    "assert np.array_equal(SimplexAlgorithm(function_to_minimax, constraints, \"min\").iloc[2,0], [0, 3, 4])\n",
    "\n",
    "constraints = np.array([[1,1,0,1],\n",
    "                        [1,-2,1,-1]])\n",
    "function_to_minimax = np.array([[5, 2, 3, 0]])\n",
    "assert SimplexAlgorithm(function_to_minimax, constraints, \"min\").iloc[0,0] == 3\n",
    "assert np.array_equal(SimplexAlgorithm(function_to_minimax, constraints, \"min\").iloc[2,0], [0.33333, 0.66667])\n",
    "\n",
    "constraints = np.array([[2, 3, 15],\n",
    "                        [1, 1, 6],\n",
    "                        [5, 3, 9]])\n",
    "function_to_minimax = np.array([[20, 24, 0]])\n",
    "assert SimplexAlgorithm(function_to_minimax, constraints, \"min\").iloc[0,0] == 132\n",
    "assert np.array_equal(SimplexAlgorithm(function_to_minimax, constraints, \"min\").iloc[2,0], [3, 3, 15])\n",
    "print(\"The function SimplexAlgorithm work correctly when goal == 'min'\")\n",
    "\n",
    "\n",
    "# Knapsack probelm\n",
    "assert KnapsackProblem(weights = [36, 24, 30, 32, 26], utility = [54, 18, 60, 32, 13], capacity = 91).iloc[0, 0] == [1,1,0,1,0]\n",
    "assert KnapsackProblem(weights = [10, 8, 15, 12, 9], utility = [10, 4, 20, 24, 15], capacity = 40).iloc[0, 0] == [1,1,1,0,0]\n",
    "assert KnapsackProblem(weights = [25, 40, 30, 50, 50], utility = [28, 48, 37, 62, 59], capacity = 130).iloc[0, 0] == [1,1,0,1,0]\n",
    "assert KnapsackProblem(weights = [23, 12, 10, 30, 13], utility = [50, 25, 15, 55, 20], capacity = 50).iloc[0, 0] == [1,1,0,1,0]\n",
    "assert KnapsackProblem(weights = [15, 14, 10, 11, 4], utility = [40, 42, 32, 25, 9], capacity = 25).iloc[0, 0] == [1,1,0,0,0]\n",
    "print(\"The KnapsackProblem function works correctly\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Dynamic Models"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 112,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The DynamicModels function works correctly for the Consensum Dynamics Model\n",
      "The DynamicModels function works correctly for the Linear Dynamic Population Redistribution Model\n"
     ]
    }
   ],
   "source": [
    "# Dynamic models\n",
    "# Consensum Dynamics\n",
    "matrix = np.array([[0, 0.5, 0.25],  \n",
    "                   [0.5, 0, 0.25],\n",
    "                   [0.25, 0.25, 0]])\n",
    "assert np.array_equal(DynamicModels(matrix, x_t0 = [4, 8 ,2], x_tn = 1, type_of_model = \"cd\", u = [0.5, 0.5, 0.5])[0].loc[:, \"Asymptotic solution\"][0], [5, 5, 5])\n",
    "\n",
    "matrix = np.array([[0, 1/2, 1/3],  \n",
    "                   [1/2, 0, 1/4],\n",
    "                   [1/3, 1/4, 0]])\n",
    "assert np.array_equal(DynamicModels(matrix, x_t0 = [4, 8 ,2], x_tn = 1, type_of_model = \"cd\", u = [0.5, 0.5, 0.5])[0].loc[:, \"Asymptotic solution\"][0], [4.84614, 4.84614, 4.84614])\n",
    "\n",
    "matrix = np.array([[0, 0.5, 0.25],  \n",
    "                   [0.5, 0, 0.25],\n",
    "                   [0.5, 1/3, 0]])\n",
    "assert np.array_equal(DynamicModels(matrix, x_t0 = [4, 8 ,2], x_tn = 1, type_of_model = \"cd\", u = [0.5, 0.5, 0.5])[0].loc[:, \"Asymptotic solution\"][0], [4.94001, 4.94001, 4.94001])\n",
    "\n",
    "matrix = np.array([[0, 0.5, 1/3],  \n",
    "                   [0.5, 0, 0.25],\n",
    "                   [0.25, 0.25, 0]])\n",
    "assert np.array_equal(DynamicModels(matrix, x_t0 = [4, 8 ,2], x_tn = 1, type_of_model = \"cd\", u = [0.5, 0.5, 0.5])[0].loc[:, \"Asymptotic solution\"][0], [4.89553, 4.89553, 4.89553])\n",
    "\n",
    "print(\"The DynamicModels function works correctly for the Consensum Dynamics Model\")\n",
    "\n",
    "# Linear Dynamic Population Redistribution Model \n",
    "matrix = np.array([[0.6, 0.1, 0.1],\n",
    "                   [0.3, 0.8, 0.2],\n",
    "                   [0.1, 0.1, 0.7]])\n",
    "assert np.array_equal(DynamicModels(matrix, x_t0 = [40, 40, 20], x_tn = 1, type_of_model = \"pop\", N = 100)[0].loc[:, \"Asymptotic solution\"][0], [20, 55, 25])\n",
    "\n",
    "matrix = np.array([[0.6, 0.1, 0.1],\n",
    "                   [0.3, 0.8, 0.3],\n",
    "                   [0.1, 0.1, 0.6]])\n",
    "assert np.array_equal(DynamicModels(matrix, x_t0 = [40, 40, 20], x_tn = 1, type_of_model = \"pop\", N = 100)[0].loc[:, \"Asymptotic solution\"][0], [20, 60, 20])\n",
    "\n",
    "matrix = np.array([[0.7, 0.1, 0.1],\n",
    "                   [0.2, 0.8, 0.3],\n",
    "                   [0.1, 0.1, 0.6]])\n",
    "assert np.array_equal(DynamicModels(matrix, x_t0 = [40, 40, 20], x_tn = 1, type_of_model = \"pop\", N = 100)[0].loc[:, \"Asymptotic solution\"][0], [25, 55, 20])\n",
    "\n",
    "matrix = np.array([[0.8, 0.1, 0.1],\n",
    "                   [0.1, 0.7, 0.3],\n",
    "                   [0.1, 0.2, 0.6]])\n",
    "\n",
    "assert np.array_equal(DynamicModels(matrix, x_t0 = [40, 40, 20], x_tn = 1, type_of_model = \"pop\", N = 100)[0].loc[:, \"Asymptotic solution\"][0], [33.33333, 38.88889, 27.77778])\n",
    "\n",
    "print(\"The DynamicModels function works correctly for the Linear Dynamic Population Redistribution Model\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
